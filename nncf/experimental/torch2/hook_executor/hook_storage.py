# Copyright (c) 2024 Intel Corporation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#      http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from enum import Enum

import torch
from torch import nn


class HookType(Enum):
    """
    Enumeration for defining types of hooks.
    """

    PRE_HOOK = "pre_hook"
    POST_HOOK = "post_hook"

    def __str__(self) -> str:
        """
        Return the string representation of the HookType.
        """
        return self.value


class HookStorage(nn.Module):
    """
    A module for storing and executing hooks.

    The storage structure is defined as:
        storage[GROUP_NAME][HOOK_TYPE__OP_NAME__PORT_ID]

    Order of module execution depends from group_name: sorted()

    :param storage: A nested dictionary structure for storing hooks.
    """

    def __init__(self) -> None:
        """
        Initialize an empty HookStorage.
        """
        super().__init__()
        self.storage: nn.ModuleDict = nn.ModuleDict()

    @staticmethod
    def _generate_key(hook_type: HookType, op_name: str, port_id: int) -> str:
        """
        Return key for module dict that generated by hook type, operation name and port id.

        :param hook_type: The type of the hook (pre-hook or post-hook).
        :param op_name: The operation name the hook is associated with.
        :param port_id: The port ID the hook is associated with.
        :returns: Generate key for module dict.
        """

        return f"{hook_type.value}__{op_name}__{port_id}"

    def insert_hook(self, group_name: str, hook_type: HookType, op_name: str, port_id: int, module: nn.Module) -> None:
        """
        Insert a hook module into the storage.

        :param group_name: The group name under which the hook is categorized.
        :param hook_type: The type of the hook (pre-hook or post-hook).
        :param op_name: The operation name the hook is associated with.
        :param port_id: The port ID the hook is associated with.
        :param module: The hook module to be stored.
        """
        hook_key = self._generate_key(hook_type, op_name, port_id)
        if group_name not in self.storage:
            self.storage[group_name] = nn.ModuleDict()
        if hook_key in self.storage[group_name]:
            raise RuntimeError(f"Hook already set for {hook_type=} {group_name=} {op_name=} {port_id=}")
        self.storage[group_name][hook_key] = module

    def execute_hook(self, hook_type: HookType, op_name: str, port_id: int, value: torch.Tensor) -> torch.Tensor:
        """
        Execute hooks stored by group_name for a specific operation and port.

        :param hook_type: The type of the hook to execute (pre-hook or post-hook).
        :param op_name: The operation name the hook is associated with.
        :param port_id: The port ID the hook is associated with.
        :param value: The tensor value to be processed by the hook.
        :returns: The processed tensor value after all applicable hooks have been applied.
        """
        hook_key = self._generate_key(hook_type, op_name, port_id)
        for group_name in sorted(self.storage):
            if hook_key in self.storage[group_name]:
                value = self.storage[group_name][hook_key](value)
        return value

    def remove_group(self, group_name: str) -> None:
        """
        Remove all hooks associated with a specific group name.

        :param group_name: The group name to remove from the storage.
        """
        self.storage.pop(group_name)
